---
import BaseLayout from "../layouts/BaseLayout.astro";
import { supabase } from "../lib/supabase";

const accessToken = Astro.cookies.get("sb-access-token");
const refreshToken = Astro.cookies.get("sb-refresh-token");

if (!accessToken || !refreshToken) {
  return Astro.redirect("/");
}

let session;
try {
  session = await supabase.auth.setSession({
    refresh_token: refreshToken.value,
    access_token: accessToken.value,
  });
  if (session.error) {
    Astro.cookies.delete("sb-access-token", {path: "/",});
    Astro.cookies.delete("sb-refresh-token", {path: "/",});
    return Astro.redirect("/");
  }
} catch (error) {
  Astro.cookies.delete("sb-access-token", {
    path: "/",
  });
  Astro.cookies.delete("sb-refresh-token", {
    path: "/",
  });
  return Astro.redirect("/");
 }
const {data, error} = await supabase.from('cameras').select('*');
---
<BaseLayout>
  
  <h1>Dashboard </h1>

  <h2>Cameras</h2>
  <ul id="cam-list" style="list-style: none; padding-left: 0;"></ul>

  <!--
  {error && <p>Error: {error}</p>}

  {test_users ? (
    test_users.map(({ username, password }) => (
      <article>
        <p>User: {username}</p>
        <p>{password}</p>
      </article>
    ))): (
    <p>Pas de données à afficher.</p>
    )
  } -->
  <br>
  <h2>Scan active cameras</h2>
  <form id="scan-form">
    <div class="input-line">
      <div class="input-group">
        <label>Username</label>
        <input type="text" id="username" value="admin" class="my-input" required>
      </div>
      <div class="input-group">
        <label>Password</label>
        <input type="password" id="password" value="Bkcs@123" class="my-input" required>
      </div>
      
      <div class="align-right">
        <div class="input-group">
          <button type="submit" class="outline">Scan Cameras</button>
        </div>
      </div>
    </div>
    

  </form> 

  <h5 id="output">Results will appear here... </h5> 



  <script type="module">

    async function fetchCameras(recentScanResults = []) {
      const res = await fetch('/api/list-camDB');
      const data = await res.json();

      const list = document.getElementById('cam-list');
      list.innerHTML = '';

      if (data.error) {
        list.innerHTML = '<li style="color: red;">Fetching error</li>';
        return;
      }

      if (!data.cameras || data.cameras.length === 0) {
        list.innerHTML = '<li>No cameras found</li>';
        return;
      }

      data.cameras.forEach(camera => {
        const li = document.createElement('li');
        li.style.marginBottom = '1em';
        li.style.cursor = 'pointer';

        const summary = document.createElement('div');
        summary.style.fontWeight = 'bold';
        summary.style.display = 'flex';
        summary.style.alignItems = 'center';
        summary.style.gap = '0.5em';

        const arrow = document.createElement('span');
        arrow.textContent = '▼';

        const status = document.createElement('span');

        const ipSpan = document.createElement('test');
        ipSpan.textContent = camera.ip;
        ipSpan.style.padding = '0.15rem 1rem';

        const isActive = recentScanResults.some(scan => scan.ip === camera.ip && scan.info?.serialNumber === camera.serial);
        if (isActive) {
          ipSpan.classList.add('active-outline');
          status.textContent = 'Connected'
        } else {
          ipSpan.classList.add('outline');
          status.textContent = 'Previously connected'
        }        

        summary.appendChild(arrow);
        summary.appendChild(ipSpan);
        summary.appendChild(status);

        const details = document.createElement('div');
        details.style.display = 'none';
        details.style.paddingLeft = '1em';
        details.innerHTML = `
          <div class="input-line">
            <div class="input-group">
              <p><strong>Port:</strong> ${camera.port || '-'}</p>
              <p><strong>Model:</strong> ${camera.model || '-'}</p>
              <p><strong>Manufacturer:</strong> ${camera.manufacturer || '-'}</p>
            </div>
            <div class="input-group">
              <p><strong>Firmware:</strong> ${camera.firmware || '-'}</p>
              <p><strong>Serial:</strong> ${camera.serial || '-'}</p>
            </div>
          </div>
        `;

        summary.addEventListener('click', () => {
          const isOpen = details.style.display === 'block';
          details.style.display = isOpen ? 'none' : 'block';
          arrow.textContent = isOpen ? '▼' : '▲';
        });

        li.appendChild(summary);
        li.appendChild(details);
        list.appendChild(li);
      });
    }

    

    document.getElementById('scan-form').addEventListener('submit', async (e) => {
      e.preventDefault();
      const username = document.getElementById('username').value;
      const password = document.getElementById('password').value;
      const output = document.getElementById('output');

      output.textContent = 'Scanning...';

      try {
        const resScan = await fetch('/api/scan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password }),
        });
        const data = await resScan.json();

        await fetchCameras(data.cameras);

        output.textContent = 'Scan finished OK';
        // output.textContent = JSON.stringify(data.cameras, null, 2);
      } catch (err) {
        output.textContent = 'Error during scan. Check console.';
        console.log(err);
      }
    });

    fetchCameras();
  </script>



<!--   <video id="video" autoplay muted controls playsinline style="width: 100%; height: auto;"></video> -->

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const video = document.getElementById("video");
      if (!(video instanceof HTMLVideoElement)) {
        console.error("Video element not found or incorrect type");
        return;
      }
  
      const mse = new MediaSource();
      video.src = URL.createObjectURL(mse);
      video.onerror = () => {
        console.error("Video error:", video.error);
      };
  
      mse.addEventListener("sourceopen", () => {
        //console.log("MediaSource opened, readyState:", mse.readyState);
        const mimeCodec = 'video/mp4; codecs="avc1.640033"';
        
        if (!MediaSource.isTypeSupported(mimeCodec)) {
          console.error("Unsupported MIME type or codec:", mimeCodec);
          return;
        }
        
        const sourceBuffer = mse.addSourceBuffer(mimeCodec);
        let queue: ArrayBuffer[] = [];
  
        const ws = new WebSocket("wss://192.168.50.182/stream/0c82d955-bf64-4934-9a6f-7f72f3061816/channel/0/mse?uuid=0c82d955-bf64-4934-9a6f-7f72f3061816&channel=0");
        ws.binaryType = "arraybuffer";
  
        ws.onmessage = (event) => {
          //console.log("Incoming data chunk of size:", event.data.byteLength);
          
          if (event.data.byteLength < 100) {
            console.warn("Skipping small chunk of size:", event.data.byteLength);
            return;
          }
          
          /*
          if (queue.length === 0 && !sourceBuffer.updating) {
            console.log("First chunk received:", new Uint8Array(event.data).slice(0, 20));
          }*/
  
          if (sourceBuffer.updating || queue.length > 0) {
            queue.push(event.data);
            //console.log("Data added to queue, queue size:", queue.length);
          } else {
            try {
              sourceBuffer.appendBuffer(event.data);
              //console.log("Appending chunk of size", event.data.byteLength);
            } catch (e) {
              console.error("appendBuffer failed", e);
            }
          }
        };
  
        sourceBuffer.addEventListener("updateend", () => {
          //console.log("SourceBuffer updated, queue size:", queue.length);
  
          if (queue.length > 0 && !sourceBuffer.updating) {
            const next = queue.shift();
            if (next) {
              try {
                sourceBuffer.appendBuffer(next);
                //console.log("Appending next chunk from queue, queue size:", queue.length);
              } catch (e) {
                console.error("appendBuffer failed while processing queue", e);
              }
            }
          }
  
          if (video.readyState >= 3) { // HAVE_FUTURE_DATA
            video.play().catch(e => console.warn("Playback error:", e));
          }
        });
  
        sourceBuffer.addEventListener("error", (e) => {
          console.error("SourceBuffer error:", e);
        });
  
        ws.onopen = () => console.log("WebSocket connected");
        ws.onerror = (err) => console.error("WebSocket error:", err);
        ws.onclose = () => console.log("WebSocket closed");
  
        /*
        video.addEventListener("playing", () => {
          console.log("Video is playing.");
        });
        video.addEventListener("waiting", () => {
          console.log("Video is waiting for more data.");
        });
  
        setInterval(() => {
          console.log("Current MediaSource readyState:", mse.readyState);
          console.log("Video readyState:", video.readyState);
          if (video.buffered.length > 0) {
            console.log("Buffered ranges:", video.buffered.start(0), "-", video.buffered.end(0));
          } else {
            console.log("No buffered ranges yet.");
          }
        }, 1000);*/
      });
    });
  </script>
  
  <!--  
  <iframe src="https://192.168.50.182:443/pages/player/all/cam1/0" width="1200" height="900" allow="autoplay; fullscreen"></iframe>
  <video controls autoplay>
    <source src="/video/output.mp4" type="video/mp4">
  </video>
  <iframe src="https://player.twitch.tv/?channel=amawswe&enableExtensions=true&muted=true&parent=samuelborioscctvsite.netlify.app&player=popout&quality=auto" width="640" height="660" frameborder="no" scrolling="no" allowfullscreen="true"></iframe>
  -->

</BaseLayout>